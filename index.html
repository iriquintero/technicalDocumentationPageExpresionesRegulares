<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Technical Documentation Page</title>
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@300;400;600;700;800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <nav id="navbar">
        <header>Expresiones Regulares</header>
        <ul>
            <li><a class="nav-link" href="#Introducción">Introducción</a></li>
            <li><a class="nav-link" href="#Crear_una_expresion_regular">Crear una expresion regular</a></li>
            <li><a class="nav-link" href="#Escribir_un_patrón_de_expresión_regular">Escribir un patrón de expresión regular</a></li>
            <li><a class="nav-link" href="#Usar_expresiones_regulares_en_JavaScript">Usar expresiones regulares en JavaScript</a></li>
            <li><a class="nav-link" href="#Ejemplos">Ejemplos</a></li>
            <li><a class="nav-link" href="#Referencia">Referencia</a></li>
        </ul>
    </nav>
    <main id="main-doc">
        <section class="main-section" id="Introducción">
            <header>Introducción</header>
            <article>
                <p>Las expresiones regulares son patrones que se utilizan para hacer coincidir combinaciones de caracteres en cadenas. En JavaScript, las expresiones regulares también son objetos. Estos patrones se utilizan con los métodos <b>exec()</b> y <b>test()</b> de <b>RegExp</b>, y con <b>match()</b>, <b>matchAll()</b>, <b>replace()</b>, <b>replaceAll()</b>, <b>search()</b> y <b>split()</b> métodos de <b>String</b>. Este capítulo describe las expresiones regulares de JavaScript.</p>
            </article>
        </section>
        <section class="main-section" id="Crear_una_expresion_regular">
            <header>Crear una expresion regular</header>
            <article>
              <ul>
                <li>Usando una expresión regular literal, que consiste en un patrón encerrado entre barras, como sigue:
                  <code>let re = /ab+c/;</code>
                  <p>Las expresiones regulares literales proporcionan la compilación de la expresión regular cuando se carga el script. Si la expresión regular permanece constante, su uso puede mejorar el rendimiento.</p>
                </li>
                <li>O llamando a la función constructora del objeto RegExp, de la siguiente manera:
                  <code>let re = new RegExp('ab+c');</code>
                  <p>El uso de la función constructora proporciona una compilación en tiempo de ejecución de la expresión regular. Usa la función constructora cuando sepas que el patrón de la expresión regular cambiará, o no conoces el patrón y lo obtienes de otra fuente, como la entrada del usuario.</p>
                </li>
              </ul>
            </article>
        </section>
        <section class="main-section" id="Escribir_un_patrón_de_expresión_regular">
            <header>Escribir un patrón de expresión regular</header>
            <article>
                <p>Un patrón de expresión regular se compone de caracteres simples, como /abc/, o una combinación de caracteres simples y especiales, como /ab*c/ o /Capítulo (\d)\.\d*/. El último ejemplo incluye paréntesis, que se utilizan como dispositivos de memoria. La coincidencia realizada con esta parte del patrón se recuerda para su uso posterior, como se describe en Uso de grupos.</p>
                <p>Nota: Si ya estás familiarizado con las formas de una expresión regular, también puedes leer la hoja de referencia para una búsqueda rápida de un patrón/construcción específica.</p>
                <h2>Usar patrones simples</h2>
                <p>Los patrones simples se construyen con caracteres para los que deseas encontrar una coincidencia directa. Por ejemplo, el patrón /abc/ coincide con combinaciones de caracteres en cadenas solo cuando ocurre la secuencia exacta "abc" (todos los caracteres juntos y en ese orden). Tal coincidencia tendría éxito en las cadenas "Hola, ¿conoces tu abc?" y "Los últimos diseños de aviones evolucionaron a partir de slabcraft". En ambos casos, la coincidencia es con la subcadena "abc". No hay ninguna coincidencia en la cadena "Grab crab" porque aunque contiene la subcadena "ab c", no contiene la subcadena "abc" exacta.</p>
                <h2>Usar caracteres especiales</h2>
                <p>Cuando la búsqueda de una coincidencia requiere algo más que una coincidencia exacta, como por ejemplo buscar una o más 'b', o encontrar espacios en blanco, puedes incluir caracteres especiales en el patrón. Por ejemplo, para hacer coincidir una sola "a" seguida de cero o más "b"s seguidas de "c", usarías el patrón /ab*c/: el * después de "b" significa "0 o más apariciones del elemento anterior". En la cadena "cbbabbbbcdebc", este patrón coincidirá con la subcadena "abbbbc".</p>
                <p>Las siguientes páginas proporcionan listas de los diferentes caracteres especiales que encajan en cada categoría, junto con descripciones y ejemplos:</p>
                <ul>
                  <li><b>Aserciones:</b>Las aserciones incluyen límites, que indican el comienzo y el final de líneas y palabras, y otros patrones que indican de alguna manera que el reconocimiento es posible (incluidas las expresiones anticipadas, inversas y condicionales). Caracteres o construcciones: ^, $, x(?=y), x(?!y), (?<span><</span>=y)x, (?<span><</span>!y)x, \b, \B . </li>
                  <li><b>Grupos y rangos:</b> Indica grupos y rangos de caracteres de expresión. Caracteres o construcciones: (x), (?:x), (?<span><</span>Name<span>></span>x), x|y, [xyz], [^xyz], \Number .</li>
                  <li><b>Cuantificadores:</b> Indica el número de caracteres o expresiones que deben coincidir. Caracteres o construcciones:  *, +, ?, x{n}, x{n,}, x{n,m}</li>
                  <li><b>Escapes de propiedades Unicode:</b> Distinguir según las propiedades de los caracteres Unicode, por ejemplo, letras mayúsculas y minúsculas, símbolos matemáticos y de puntuación. Caracteres o construcciones: \p{UnicodeProperty}, \P{UnicodeProperty} .</li>
                </ul>

                <h2>Escapando</h2>
                <p>Si necesitas usar literalmente cualquiera de los caracteres especiales (en realidad buscando un "*", por ejemplo), lo debes escapar colocando una barra invertida delante de él. Por ejemplo, para buscar "a" seguido de "*" seguido de "b", usarías /a\*b/ — la barra invertida "escapa" de "*", volviéndola literal en lugar de especial.</p>
                <p>De manera similar, si estás escribiendo un literal de expresión regular y necesitas buscar una barra inclinada ("/"), la debes escapar (de lo contrario, esta termina el patrón). Por ejemplo, para buscar la cadena "/ejemplo/" seguida de uno o más caracteres alfabéticos, usarías /\/ejemplo\/[a-z]+/i: las barras invertidas antes de cada barra, las hace literales.</p>
                <p>Para hacer coincidir una barra invertida literal, debes escapar de la barra invertida. Por ejemplo, para encontrar la cadena "C:\" donde "C" puede ser cualquier letra, usarías /[A-Z]:\\/ — la primera barra invertida escapa a la que sigue, por lo que la expresión busca una sola barra invertida literal.</p>
                <p>Si usas el constructor RegExp con un literal de cadena, recuerda que la barra invertida es un escape en los literales de cadena, por lo que para usarlo en la expresión regular, debes escapar en el nivel del literal de cadena. /a\*b/ y new RegExp("a\\*b") crean la misma expresión, que busca "a" seguida de un "*" literal seguido de "b".</p>
                <p>Si las cadenas de escape aún no forman parte de tu patrón, puedes agregarlas usando String.replace:</p>
                <code>function escapeRegExp(string) {
                  return string.replace(/[.*+\-?^${}()|[\]\\]/g,'\\$&'); // $& significa toda la cadena coincidente
                }</code>
                <p>La "g" después de la expresión regular es una opción o indicador que realiza una búsqueda global, buscando en toda la cadena y devolviendo todas las coincidencias. Se explica en detalle a continuación en Búsqueda avanzada con indicadores.</p>
                <p>¿Por qué no está integrada en JavaScript? Existe una propuesta para agregar esta función a RegExp, pero fue rechazada por TC39.</p>
                <h2>Usando paréntesis</h2>
                <p>Los paréntesis alrededor de cualquier parte del patrón de expresión regular hacen que se recuerde esa parte de la subcadena coincidente. Una vez reconocida, la subcadena se puede recuperar para otro uso. Consulta Grupos y rangos para obtener más detalles.</p>
                
                </article>
            </section>
            <section class="main-section" id="Usar_expresiones_regulares_en_JavaScript">
                <header>Usar expresiones regulares en JavaScript</header>
            <article>
                <p>Las expresiones regulares se utilizan con los métodos RegExp test() y exec() y con los métodos de String, match(), replace(), search() y split(). Estos métodos se explican en detalle en la referencia de JavaScript.</p>
                <ul>
                  <li><b>exec()</b>: Ejecuta una búsqueda por una coincidencia en una cadena. Devuelve un arreglo de información o null en una discrepancia.</li>
                  <li><b>test()</b>: Prueba una coincidencia en una cadena. Devuelve true o false.</li>
                  <li><b>match()</b>: Devuelve un arreglo que contiene todas las coincidencias, incluidos los grupos de captura, o null si no se encuentra ninguna coincidencia. </li>
                  <li><b>matchAll()</b>: Devuelve un iterador que contiene todas las coincidencias, incluidos los grupos de captura. </li>
                  <li><b>search()</b>: Prueba una coincidencia en una cadena. Devuelve el índice de la coincidencia, o -1 si la búsqueda falla. </li>
                  <li><b>replace()</b>: Ejecuta una búsqueda por una coincidencia en una cadena y reemplaza la subcadena coincidente con una subcadena de reemplazo.</li>
                  <li><b>replaceAll()</b>: Ejecuta una búsqueda de todas las coincidencias en una cadena y reemplaza las subcadenas coincidentes con una subcadena de reemplazo. </li>
                  <li><b>split()</b>: Utiliza una expresión regular o una cadena fija para dividir una cadena en un arreglo de subcadenas.</li>
                </ul>
                <p>Cuando desees saber si un patrón se encuentra en una cadena, utiliza los métodos test() o search(); para obtener más información (pero una ejecución más lenta) utiliza los métodos exec() o match(). Si usas exec() o match() y si la búsqueda tiene éxito, estos métodos devuelven un arreglo y actualizan las propiedades del objeto expresión regular asociado y también del objeto de expresión regular predefinido, el objeto RegExp. Si la búsqueda falla, el método exec() devuelve null (que coacciona a false).</p>
                <p>En el siguiente ejemplo, el script utiliza el método exec() para encontrar una coincidencia en una cadena.</p>
                <code>var myRe = /d(b+)d/g;
                  var myArray = myRe.exec('cdbbdbsbz');</code>
                <p>Si no necesitas acceder a las propiedades de la expresión regular, una forma alternativa de crear myArray es con este script:</p>
                <code> var myArray = /d(b+)d/g.exec('cdbbdbsbz');
    // similar a "cdbbdbsbz" .match(/d(b+)d/g); sin embargo,
    // "cdbbdbsbz" .match (/d(b+)d/g) genera Array ["dbbd"], mientras
    // /d(b+)d/g.exec('cdbbdbsbz ') produce Array ['dbbd', 'bb', index: 1, input: 'cdbbdbsbz' ].
                </code>
                <p>(Consulta diferentes comportamientos para obtener más información sobre los diferentes comportamientos).</p>
                <p>Si deseas construir la expresión regular a partir de una cadena, otra alternativa más es este script:</p>
                <code>var myRe = new RegExp('d(b+)d', 'g');
                  var myArray = myRe.exec('cdbbdbsbz');</code>
                <p>Como se muestra en la segunda forma de este ejemplo, puedes usar una expresión regular creada con un iniciador de objeto sin asignarla a una variable. Sin embargo, si lo hace, cada aparición es una nueva expresión regular. Por este motivo, si utilizas esta forma sin asignarla a una variable, no podrás acceder posteriormente a las propiedades de esa expresión regular. Por ejemplo, supongamos que tienes este script:</p>
                <code>var myRe = /d(b+)d/g;
                  var myArray = myRe.exec('cdbbdbsbz');
                  console.log('El valor de lastIndex es ' + myRe.lastIndex);
                  
                  // "El valor de lastIndex es 5"</code>
                <p>Sin embargo, si tienes este script:</p>
                <code>var myArray = /d(b+)d/g.exec('cdbbdbsbz');
                  console.log('El valor de lastIndex es ' + /d(b+)d/g.lastIndex);
                  
                  // "El valor de lastIndex es 0"</code>
                <p>Las apariciones de /d(b+)d/g en las dos declaraciones son objetos de expresión regular diferentes y, por lo tanto, tienen valores diferentes para su propiedad lastIndex. Si necesitas acceder a las propiedades de una expresión regular creada con un iniciador de objeto, primero debes asignarla a una variable.</p>

            </article>
        </section>
        <section class="main-section" id="Ejemplos">
            <header>Ejemplos</header>
            <article>
              <p></p>
            </article>
        </section>
        <section class="main-section" id="Referencia">
            <header>Referencia</header>
            <article><a href="https://es.reactjs.org/docs/getting-started.html" target="_blank">React</a></article>
        </section>

    </main>
    <script src="https://cdn.freecodecamp.org/testable-projects-fcc/v1/bundle.js"></script>
</body>
</html>